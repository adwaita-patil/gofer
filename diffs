Only in go32s: changelo
diff go32s/control.c \djgpp\go32/control.c
160,167d159
< #ifdef GO32_STAT
< //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
< FILE *pstrmStat;
< long alStat[256];
< long alStat21[256];
< long alStatTurboAssist[256];
< #endif
< 
183,206d174
< 
< #ifdef GO32_STAT
< //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
<    {
<    register int i;
< 
<    for (i = 0; i < 256; i++) {
<       if (alStat[i] != 0)
<          fprintf(pstrmStat, "\ni = %3.3d - %2.2x - Count = %6.6lu", i, i, alStat[i]);
<       }
<    
<    fprintf(pstrmStat, "\n\nINT 0x21 calls ----------------------");
<    for (i = 0; i < 256; i++) {
<       if (alStat21[i] != 0)
<          fprintf(pstrmStat, "\ni = %3.3d - %2.2x - Count = %6.6lu", i, i, alStat21[i]);
<       }
< 
<    fprintf(pstrmStat, "\n\nTurbo Assist calls ----------------------");
<    for (i = 0; i < 256; i++) {
<       if (alStatTurboAssist[i] != 0)
<          fprintf(pstrmStat, "\ni = %3.3d - %2.2x - Count = %6.6lu", i, i, alStatTurboAssist[i]);
<       }
<    }
< #endif
210,212c178
< int ctrlbrk_func();
< //111111111111111111111111111111111111111111111111111111111111111111111111111
< /*  moved to exphdlr.c *********
---
> 
221,222d186
< *************/
< //111111111111111111111111111111111111111111111111111111111111111111111111111
233,236c197
< //111111111111111111111111111111111111111111111111111111111111111111111111111
< word32 push32(void *ptr, int len);
< //111111111111111111111111111111111111111111111111111111111111111111111111111
< // static word32 push32(void *ptr, int len);
---
> static word32 push32(void *ptr, int len);
279,287d239
< #ifdef GO32_STAT
< //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
<    printf("Statistics version\n");
<    pstrmStat = fopen(GO32_STAT, "w");
<    memset(alStat, 0, 256);
<    memset(alStat21, 0, 256);
<    memset(alStatTurboAssist, 0, 256);
< #endif
< 
623,626c575
< //111111111111111111111111111111111111111111111111111111111111111111111111111
< word32 push32(void *ptr, int len)
< //111111111111111111111111111111111111111111111111111111111111111111111111111
< // static word32 push32(void *ptr, int len)
---
> static word32 push32(void *ptr, int len)
diff go32s/exphdlr.c \djgpp\go32/exphdlr.c
37,39d36
< //111111111111111111111111111111111111111111111111111111111111111111111111111
< #include "go32sig.h"
< //111111111111111111111111111111111111111111111111111111111111111111111111111
94,96c91
< #ifdef DEBUG_PIC
<     printf("Empty = %x\n", try[i]);
< #endif
---
> /*    printf("Empty = %d\n", try[i]); */
111,113c106
< #ifdef DEBUG_PIC
<     printf("VCPI pics were m=%x s=%x\n", old_master_lo, hard_slave_lo);
< #endif
---
> /*    printf("VCPI pics were m=%d s=%d\n", old_master_lo, hard_slave_lo); */
141,151d133
< 
< #ifdef DEBUG_PIC
<    printf("\nIn init controllers :"
<           "\nhard_master_lo = %x"
<           "\nhard_slave_lo = %x"
<           "\nhard_slave_hi = %x"
<           "\nold_master_lo = %x"
<          , (int)hard_master_lo, (int)hard_slave_lo, (int)hard_slave_hi
<          , (int)old_master_lo
<       );
< #endif
169,176d150
< #ifdef GO32_STAT
< //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
< extern FILE *pstrmStat;
< extern long alStat[256];
< extern long alStat21[256];
< extern long alStatTurboAssist[256];
< #endif
< 
192c166
<        && (i != hard_slave_hi + 5) && (i != 0x75))
---
>        && (i != hard_slave_hi + 5))
205,212c179
< 
<          //111111111111111111111111111111111111111111111111111111111111111111
< 	      // here is where you land when you do an interrupt 
< 	      // during a tight loop
<    	   ctrlbrk_func();
< 	      return 0;
<          // ctrl_c_flag = 1;
<          //111111111111111111111111111111111111111111111111111111111111111111
---
>           ctrl_c_flag = 1;
223,229d189
< 
< #ifdef GO32_STAT
< //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
< // fprintf(pstrmStat, "\ni = %3.3d - %2.2x - AX = %4.4x", i, i, (unsigned short)tss_ptr->tss_eax);
< alStat[i]++;
< #endif
< 
250,256c210
<       //111111111111111111111111111111111111111111111111111111111111111111
< #ifdef DEBUG_PIC
<       printf("\nIn interrupt 0x75");
< #endif
<       return fpe_func();	/* floating point exception */
<       /* return 1; */
<       //111111111111111111111111111111111111111111111111111111111111111111
---
>       return 1;
278,286d231
< 
<     //11111111111111111111111111111111111111111111111111111111111111111111111
<    case 0xfa : /* New interface between user program and go32 (see i_Interface()) */
< #ifdef DEBUG_SIG
<       printf("\nCalling i_Interface now");
< #endif
<       return i_Interface();
<     //11111111111111111111111111111111111111111111111111111111111111111111111
< 
458,463d402
< 
< #ifdef GO32_STAT
< //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
< alStat21[ah]++;
< #endif
< 
599,614d537
<       //111111111111111111111111111111111111111111111111111111111111111111111
<       // Are we reading from stdin
<       if (r.r_bx == 0) // stdin
<          fInRead = 2;
<       else 
<          fInRead = 1;
< 
< #ifdef DBG_READ
<    {
<    char buf[20];
<    sprintf(buf, "  In Read %2.2d, #=%3.3ld  ", ++cRead, tss_ptr->tss_ecx);
<    for (i=0; buf[i]; i++)
<       poke(screen_seg, i*2+110+2400, buf[i] | 0x0700);
<    }
< #endif
<       //111111111111111111111111111111111111111111111111111111111111111111111
628,630d550
<       //111111111111111111111111111111111111111111111111111111111111111111111
<          goto handle_interrupt;
<       //111111111111111111111111111111111111111111111111111111111111111111111
662,690d581
< 
<       //111111111111111111111111111111111111111111111111111111111111111111111
< handle_interrupt:
< 
< #ifdef DBG_READ
<       {
<       char buf[20];
<       int j;
<       sprintf(buf, "  Read Done %2.2d, #=%3.3d  ", cRead--, trans_total);
<       for (j=0; buf[j]; j++)
<          poke(screen_seg, j*2+110+2560, buf[j] | 0x0800);
< //    Extensive debugging. Reprints the last typed line.
< //	   for (j=0;j<i;j++)
< //	      poke(screen_seg, j*2+2720, transfer_buffer[j] | 0x0600);
<       }
< #endif
<       fInRead = 0;   // Read finished so reset flag
< 
<       // If had keyboard interrupt during the read, then call
<       // SIGINT handler
<       if (fHadInterrupt) {
< #ifdef DBG_READ
<          printf("\n\t\tCalling Interrupt handler from read\n");
< #endif
<          fHadInterrupt = 0;
<          ctrlbrk_func();
<          }
<       //111111111111111111111111111111111111111111111111111111111111111111111
< 
907,912d797
< 
< #ifdef GO32_STAT
< //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
< alStatTurboAssist[(tss_ptr->tss_eax & 0xff)]++;
< #endif
< 
diff go32s/go32.lnk \djgpp\go32/go32.lnk
1c1
< \borlandc\lib\c0s+
---
> c:\usr\lib\c0s+
24,25c24
< vcpi+
< go32sig.obj
---
> vcpi
28,30c27,29
< \borlandc\lib\maths+
< \borlandc\lib\emu+
< \borlandc\lib\cs
---
> udi\udi+c:\usr\lib\maths+
> c:\usr\lib\emu+
> c:\usr\lib\cs
Only in go32s: go32sig.c
Only in go32s: go32sig.h
diff go32s/makefile \djgpp\go32/makefile
5,8c5
< CFLAGS = -ms -M -I\borlandc\include -L\borlandc\lib
< # -DDEBUG_PIC : debug interrrupt controller picture
< # -DGO32_STAT="f:\\go32_stat" : generate a statistics file about interrupt calls
< # -DDEBUG_SIGFPE -DDEBUG_SIG
---
> CFLAGS = -ms -M
11,13c8,10
< #	bcc $(CFLAGS) -DDEBUGGER=1 -DTOPLINEINFO=1 -DSOURCE_LIST -c $*.c
< #	-mv $*.obj d$*.obj
< 	bcc $(CFLAGS) -DDEBUGGER=0 -DTOPLINEINFO=0 -c $*.c
---
> 	tcc $(CFLAGS) -DDEBUGGER=1 -DTOPLINEINFO=1 -DSOURCE_LIST -c $*
> 	mv $*.obj d$*.obj
> 	tcc $(CFLAGS) -DDEBUGGER=0 -DTOPLINEINFO=0 -c $*
16,17c13,14
< #	tasm $(AFLAGS) /DDEBUGGER=1 /DTOPLINEINFO=1 $*;
< #	-mv $*.obj d$*.obj
---
> 	tasm $(AFLAGS) /DDEBUGGER=1 /DTOPLINEINFO=1 $*;
> 	mv $*.obj d$*.obj
43,44c40
< 	vcpi.obj\
< 	go32sig.obj
---
> 	vcpi.obj
49c45
< 	bcc $(CFLAGS) stub.c
---
> 	tcc stub.c
52,55d47
< # no debugging information
< NOV:
< 	tlink /3    /c          @go32.lnk
< 
58,60c50,51
< 	tlink /3    /c /v       @go32.lnk
< #	tlink /3 /l /c /v /s /m @go32.lnk
< #	tlink /3 /l /c /v /s /m @debug32.lnk
---
> 	tlink /l /c /v /s /m @go32.lnk
> 	tlink /l /c /v /s /m @debug32.lnk
63c54
< 	bcc $(CFLAGS) bin2byte.c
---
> 	tcc bin2byte.c
70c61
< 	bcc $(CFLAGS) aout2exe.c
---
> 	tcc aout2exe
74c65
< 	bcc $(CFLAGS) exe2aout.c
---
> 	tcc exe2aout
diff go32s/mono.c \djgpp\go32/mono.c
3d2
< #include <stdarg.h>
70c69
<   int n = vsprintf(buf, fmt, (void _ss *) _va_ptr);
---
>   int n = vsprintf(buf, fmt, &...);
Only in go32s: sigman.s
Only in go32s: signal.c
Only in go32s: signal.h
diff go32s/stub.c \djgpp\go32/stub.c
34c34
< char emsg[] = "Cannot exec go32t.exe\r\n";
---
> char emsg[] = "Cannot exec go32.exe\r\n";
43,44c43,44
<   /* must wait, as go32t reads argv/argc from our memory space */
<   r = spawnlp(P_WAIT, "go32t", "go32t", "!proxy", s_argc, s_seg, s_argv, 0);
---
>   /* must wait, as go32 reads argv/argc from our memory space */
>   r = spawnlp(P_WAIT, "go32", "go32", "!proxy", s_argc, s_seg, s_argv, 0);
46c46
< /*  if (r == -1) perror("Cannot exec go32t"); */
---
> /*  if (r == -1) perror("Cannot exec go32"); */
Only in go32s: stubbyte.h
Only in go32s: tdconfig.td
diff go32s/turboc.cfg \djgpp\go32/turboc.cfg
5c5
< -O2
---
> -O
8c8
< -2
---
> -1
11,12c11,12
< -ID:\LANG\BC\INCLUDE
< -LD:\LANG\BC\LIB
---
> -IC:\USR\INCLUDE
> -LC:\USR\LIB
